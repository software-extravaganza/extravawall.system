
//------------------------------------------------------------------------------

//  <auto-generated>
//      This code was generated by:
//        TerminalGuiDesigner v1.0.22.0
//      You can make changes to this file and they will not be overwritten when saving.
//  </auto-generated>
// -----------------------------------------------------------------------------
namespace ExtravaWallSetup.GUI {
    using DynamicData;
    using ExtravaWallSetup.Commands;
    using ExtravaWallSetup.Commands.Framework;
    using ExtravaWallSetup.GUI.Framework;
    using Hardware.Info;
    using System;
    using System.Data;
    using System.Diagnostics;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Threading.Tasks;
    using Terminal.Gui;
    using Terminal.Gui.Graphs;
    using static Terminal.Gui.Graphs.BarSeries;

    public partial class DefaultScreen {
        private HardwareInfo _hardwareInfo;
        private DateTime _startTime;
        private Timer _systemTimer;
        private DiscoBarSeries _memSeries;
        private List<BarSeries.Bar> _memBars;
        private DiscoBarSeries _cpuSeries;
        private int _systemTimerTick = 500;
        private ScatterSeries _memPoints;
        private ScatterSeries _cpuPoints;
        private List<Bar> _cpuBars;
        private float _memPercentage;
        private float _cpuPercentage;
        private DataRow _cpuRow;
        private DataRow _memRow;
        private float _cpuGraphOffset;
        private float _memGraphOffset;
        private ColorScheme _defaultInfoTableColorScheme;
        private ColorScheme _defaultInfoTableColumnColorScheme;
        public ExtravScrollView VirtualConsoleView => consoleScrollView;
        private TaskCompletionSource _layoutInitializedCompletionSource;
        public Task LayoutInitialized => _layoutInitializedCompletionSource.Task;
        public TableView InfoTable => infoTable;

        public override bool ProcessHotKey(KeyEvent keyEvent) {
            if(keyEvent.Key == Key.Esc) {
                Terminal.Gui.Application.Shutdown();
            }

            return base.ProcessHotKey(keyEvent);
        }

        public DefaultScreen(TaskCompletionSource layoutInitializedCompletionSource) {
            _layoutInitializedCompletionSource = layoutInitializedCompletionSource;
            InitializeComponent();
            _memPoints = new ScatterSeries();
            _cpuPoints = new ScatterSeries();
            _hardwareInfo = new HardwareInfo();
            
            _startTime = DateTime.Now;
       

            _memSeries = new DiscoBarSeries();
            _memBars = new List<BarSeries.Bar>();
            _cpuSeries = new DiscoBarSeries();
            _cpuBars = new List<BarSeries.Bar>();
            _memSeries.Bars = _memBars;
            _cpuSeries.Bars = _cpuBars;
            memGraph.Series.Add(_memSeries);
            cpuGraph.Series.Add(_cpuSeries);
            _cpuGraphOffset = 0f;
            _memGraphOffset = 0f;
            memGraph.AutoSize = true;
            cpuGraph.AutoSize = true;
            _defaultInfoTableColorScheme = new ColorScheme() {
                Normal = new Terminal.Gui.Attribute(Color.Gray, Color.Blue)
            };
            _defaultInfoTableColumnColorScheme = new ColorScheme() {
                Normal = new Terminal.Gui.Attribute(Color.White)
            };

            infoTable.Style.RowColorGetter = (a) => _defaultInfoTableColorScheme;
            consoleScrollView.LayoutComplete += consoleScrollView_LayoutCompleteAsync;
            consoleScrollView.KeepContentAlwaysInViewport = true;
            consoleScrollView.Enabled = true;
            consoleScrollView.Visible = true;
            consoleScrollView.ShowHorizontalScrollIndicator = true;
            consoleScrollView.ShowVerticalScrollIndicator = true;
            consoleScrollView.ColorScheme = Colors.TopLevel;
            consoleScrollView.WantMousePositionReports = true;
            consoleScrollView.SetFocus();
            consoleScrollView.AutoSize = true;

            _systemTimer = new Timer((o) => {
                // Note the check for Mainloop being valid. System.Timers can run after they are Disposed.
                // This code must be defensive for that. 
                updateGraphs();
                Application.MainLoop?.Invoke(drawGraphs);

            }, null, 0, _systemTimerTick);
        }

        private void consoleScrollView_LayoutCompleteAsync(LayoutEventArgs obj) {
            if (!_layoutInitializedCompletionSource.Task.IsCompleted) {
                _layoutInitializedCompletionSource.SetResult();
            }
        }

        bool good = false;
        

        private void updateGraphs() {


            _hardwareInfo.RefreshMemoryStatus();
            _hardwareInfo.RefreshCPUList();
            //var timeDiff = (float)(DateTime.Now - _startTime).TotalMilliseconds;
            _memPercentage = (float)(1m - ((decimal)_hardwareInfo.MemoryStatus.AvailablePhysical / _hardwareInfo.MemoryStatus.TotalPhysical));
            _cpuPercentage = (float)(_hardwareInfo.CpuList.Average(c => (decimal)c.PercentProcessorTime) / 100);
            //var newMemPoint = new PointF(timeDiff / 1000, _memPercentage);
            //var newCpuPoint = new PointF(timeDiff / 1000, _cpuPercentage);
            var stiple = new GraphCellToRender('\u2588');
            //_memPoints.Points.Add(newMemPoint);
            //_cpuPoints.Points.Add(newCpuPoint);
            _memBars.Add(new BarSeries.Bar(null, stiple, _memPercentage));
            _cpuBars.Add(new BarSeries.Bar(null, stiple, _cpuPercentage));
            memGraph.GetCurrentWidth(out int memGraphWidth);
            cpuGraph.GetCurrentWidth(out int cpuGraphWidth);
            memGraph.GetCurrentHeight(out int memGraphHeight);
            cpuGraph.GetCurrentHeight(out int cpuGraphHeight);

            while (_memBars.Count > memGraphWidth && _memBars.Count > 0) {
                _memBars.RemoveAt(0);
            }

            while (_cpuBars.Count > cpuGraphWidth && _cpuBars.Count > 0) {
                _cpuBars.RemoveAt(0);
            }
            //memGraph.ScrollOffset = new PointF(_memGraphOffset, 0);
            //cpuGraph.ScrollOffset = new PointF(_cpuGraphOffset, 0);
        }

        private void drawGraphs() {
            //var memLine = new PathAnnotation() {
            //    LineColor = Application.Driver.MakeAttribute(Color.Green, Color.Black),
            //    Points = _memPoints.Points.ToList(),
            //    BeforeSeries = true,
            //};
            //memGraph.Annotations.Add(memLine);

            //var cpuLine = new PathAnnotation() {
            //    LineColor = Application.Driver.MakeAttribute(Color.BrightCyan, Color.Black),
            //    Points = _cpuPoints.Points.ToList(),
            //    BeforeSeries = true,
            //};
            //cpuGraph.Annotations.Add(cpuLine);

            memGraph.SetNeedsDisplay();
            cpuGraph.SetNeedsDisplay();
            cpuGraphLabel.Text = _cpuPercentage.ToString("CPU - 00%");
            memGraphLabel.Text = _memPercentage.ToString("Mem - 00%");
            infoTable.SetNeedsDisplay();

        }

    }




}
