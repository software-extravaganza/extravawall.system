
//------------------------------------------------------------------------------

//  <auto-generated>
//      This code was generated by:
//        TerminalGuiDesigner v1.0.22.0
//      You can make changes to this file and they will not be overwritten when saving.
//  </auto-generated>
// -----------------------------------------------------------------------------
namespace ExtravaWallSetup.GUI {
    using DynamicData;
    using Hardware.Info;
    using System;
    using System.Data;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using Terminal.Gui;
    using Terminal.Gui.Graphs;
    using static Terminal.Gui.Graphs.BarSeries;

    public partial class DefaultScreen {
        private HardwareInfo _hardwareInfo;
        private DateTime _startTime;
        private Timer _systemTimer;
        private DiscoBarSeries _memSeries;
        private List<BarSeries.Bar> _memBars;
        private DiscoBarSeries _cpuSeries;
        private int _systemTimerTick = 500;
        private ScatterSeries _memPoints;
        private ScatterSeries _cpuPoints;
        private List<Bar> _cpuBars;
        private float _memPercentage;
        private float _cpuPercentage;
        private DataRow _cpuRow;
        private DataRow _memRow;
        private float _cpuGraphOffset;
        private float _memGraphOffset;
        private ColorScheme _defaultInfoTableColorScheme;
        private ColorScheme _defaultInfoTableColumnColorScheme;

        public DefaultScreen() {
            InitializeComponent();
            _memPoints = new ScatterSeries();
            _cpuPoints = new ScatterSeries();
            _hardwareInfo = new HardwareInfo();
            updateSystemInfo();
            _startTime = DateTime.Now;
            _systemTimer = new Timer((o) => {
                // Note the check for Mainloop being valid. System.Timers can run after they are Disposed.
                // This code must be defensive for that. 
                updateGraphs();
                Application.MainLoop?.Invoke(drawGraphs);
            }, null, 0, _systemTimerTick);

            _memSeries = new DiscoBarSeries();
            _memBars = new List<BarSeries.Bar>();
            _cpuSeries = new DiscoBarSeries();
            _cpuBars = new List<BarSeries.Bar>();
            _memSeries.Bars = _memBars;
            _cpuSeries.Bars = _cpuBars;
            memGraph.Series.Add(_memSeries);
            cpuGraph.Series.Add(_cpuSeries);
            _cpuGraphOffset = 0f;
            _memGraphOffset = 0f;
            memGraph.AutoSize = true;
            cpuGraph.AutoSize = true;
            ////Console.WriteLine($"Used Memory: {}%");
            ////Console.WriteLine($"Cpu: {}%");
            //memGraph.Series.Add(_memPoints);
            //cpuGraph.Series.Add(_cpuPoints);

            //memGraph.AxisX.Increment = 500f;
            //memGraph.AxisX.ShowLabelsEvery = 1;
            //memGraph.AxisY.Increment = 0.1f;
            //memGraph.AxisY.ShowLabelsEvery = 5;

            //cpuGraph.AxisX.Increment = 500f;
            //cpuGraph.AxisX.ShowLabelsEvery = 1;
            //cpuGraph.AxisY.Increment = 0.1f;
            //cpuGraph.AxisY.ShowLabelsEvery = 5;
            _defaultInfoTableColorScheme = new ColorScheme() {
                Normal = new Terminal.Gui.Attribute(Color.Gray, Color.Blue)
            };
            _defaultInfoTableColumnColorScheme = new ColorScheme() {
                Normal = new Terminal.Gui.Attribute(Color.White)
            };

            infoTable.Style.RowColorGetter = (a) => _defaultInfoTableColorScheme;
            
            consoleScrollView.KeepContentAlwaysInViewport = true;
            consoleScrollView.LayoutComplete += ConsoleScrollView_LayoutComplete;
            consoleScrollView.Enabled = true;
            consoleScrollView.Visible = true;
            consoleScrollView.ShowHorizontalScrollIndicator = true;
            consoleScrollView.ShowVerticalScrollIndicator = true;
            consoleScrollView.ColorScheme = Colors.TopLevel;
            consoleScrollView.WantMousePositionReports = true;
            consoleScrollView.SetFocus();
            // consoleScrollView.Focus
            //consoleScrollView.Add(new BannerView());
            //AddConsoleContent(new BannerView());
            this.KeyPress += DefaultScreen_KeyDown;
            Terminal.Gui.Application.Resized = DefaultScreen_Resized;
        }

        private void DefaultScreen_Resized(Application.ResizedEventArgs obj) {
            ResetConsoleScroll();
        }

        private void DefaultScreen_KeyDown(KeyEventEventArgs obj) {
            if(obj.KeyEvent.Key == Key.F5) {
                ResetConsoleScroll();
                Redraw(Bounds);
            }
        }

        bool _initalLayout = false;
        private void ConsoleScrollView_LayoutComplete(LayoutEventArgs obj) {
            if (!_initalLayout) {
                _initalLayout = true;
                AddConsoleContent(new BannerView());
                AddConsoleContent(new StartMenuView());
            }
        }

        private void AddConsoleContent(View obj) {
            var lowestPosition = consoleScrollView.Subviews.First().Subviews.LastOrDefault();
            consoleScrollView.Add(obj);
            obj.GetCurrentWidth(out int currentWidth);
            obj.GetCurrentHeight(out int currentHeight);
            obj.Y = lowestPosition == null ? Pos.At(0) : Pos.Bottom(lowestPosition) + 1;
            obj.X = Pos.At(0);
            _totalScrollWidth += currentWidth;
            _totalScrollHeight += currentHeight;
            ResetConsoleScroll();
            consoleScrollView.SetFocus();
        }

        private void ResetConsoleScroll() {
            consoleScrollView.GetCurrentWidth(out int scrollViewWidth);
            consoleScrollView.GetCurrentHeight(out int scrollViewHeight);
            consoleScrollView.ContentSize = new Size(_totalScrollWidth <= scrollViewWidth ? scrollViewWidth : _totalScrollWidth, _totalScrollHeight <= scrollViewHeight ? scrollViewHeight : _totalScrollHeight);
            consoleScrollView.ContentOffset = new Point(0, consoleScrollView.ContentSize.Height - scrollViewHeight);
            consoleScrollView.SetNeedsDisplay();
        }

        private void updateSystemInfo() {
            addInfoRow(nameof(RuntimeInformation.ProcessArchitecture), RuntimeInformation.ProcessArchitecture.ToString());
            addInfoRow(nameof(RuntimeInformation.OSArchitecture), RuntimeInformation.OSArchitecture.ToString());
            addInfoRow(nameof(RuntimeInformation.FrameworkDescription), RuntimeInformation.FrameworkDescription.ToString());
            addInfoRow(nameof(RuntimeInformation.OSDescription), RuntimeInformation.OSDescription.ToString());
            addInfoRow(nameof(RuntimeInformation.RuntimeIdentifier), RuntimeInformation.RuntimeIdentifier.ToString());
            addInfoRow(nameof(RuntimeInformation.ProcessArchitecture), RuntimeInformation.ProcessArchitecture.ToString());
            addInfoRow("Current Location", AppContext.BaseDirectory.ToString());
        }
        private System.Data.DataRow addInfoRow(string property, string value) {
            List<object> row = new List<object>() {
                property,
                value
            };

            var datarow = infoTable.Table.Rows.Add(row.ToArray());
            return datarow;
        }

        bool good = false;
        private int _totalScrollWidth;
        private int _totalScrollHeight = 1;

        private void updateGraphs() {


            _hardwareInfo.RefreshMemoryStatus();
            _hardwareInfo.RefreshCPUList();
            //var timeDiff = (float)(DateTime.Now - _startTime).TotalMilliseconds;
            _memPercentage = (float)(1m - ((decimal)_hardwareInfo.MemoryStatus.AvailablePhysical / _hardwareInfo.MemoryStatus.TotalPhysical));
            _cpuPercentage = (float)(_hardwareInfo.CpuList.Average(c => (decimal)c.PercentProcessorTime) / 100);
            //var newMemPoint = new PointF(timeDiff / 1000, _memPercentage);
            //var newCpuPoint = new PointF(timeDiff / 1000, _cpuPercentage);
            var stiple = new GraphCellToRender('\u2588');
            //_memPoints.Points.Add(newMemPoint);
            //_cpuPoints.Points.Add(newCpuPoint);
            _memBars.Add(new BarSeries.Bar(null, stiple, _memPercentage));
            _cpuBars.Add(new BarSeries.Bar(null, stiple, _cpuPercentage));
            memGraph.GetCurrentWidth(out int memGraphWidth);
            cpuGraph.GetCurrentWidth(out int cpuGraphWidth);
            memGraph.GetCurrentHeight(out int memGraphHeight);
            cpuGraph.GetCurrentHeight(out int cpuGraphHeight);
            
            while (_memBars.Count > memGraphWidth) {
                _memBars.RemoveAt(0);
            }

            while (_cpuBars.Count > cpuGraphWidth) {
                _cpuBars.RemoveAt(0);
            }
            //memGraph.ScrollOffset = new PointF(_memGraphOffset, 0);
            //cpuGraph.ScrollOffset = new PointF(_cpuGraphOffset, 0);
        }

        private void drawGraphs() {
            //var memLine = new PathAnnotation() {
            //    LineColor = Application.Driver.MakeAttribute(Color.Green, Color.Black),
            //    Points = _memPoints.Points.ToList(),
            //    BeforeSeries = true,
            //};
            //memGraph.Annotations.Add(memLine);

            //var cpuLine = new PathAnnotation() {
            //    LineColor = Application.Driver.MakeAttribute(Color.BrightCyan, Color.Black),
            //    Points = _cpuPoints.Points.ToList(),
            //    BeforeSeries = true,
            //};
            //cpuGraph.Annotations.Add(cpuLine);

            memGraph.SetNeedsDisplay();
            cpuGraph.SetNeedsDisplay();
            cpuGraphLabel.Text = _cpuPercentage.ToString("CPU - 00%");
            memGraphLabel.Text = _memPercentage.ToString("Mem - 00%");
            infoTable.SetNeedsDisplay();

        }

    }
}
