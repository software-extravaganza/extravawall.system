using System.Linq;
using Microsoft.CodeAnalysis;
using System.Text;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Reflection;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Globalization;
using System.CodeDom.Compiler;
using Microsoft.CodeAnalysis.CSharp;


namespace ExtravaCore.Generators;



[Generator(LanguageNames.CSharp)]
public sealed class ExampleGenerator : IIncrementalGenerator {
    private static readonly AssemblyName AssemblyName = typeof(ExampleGenerator).Assembly.GetName();
    private static readonly string generatedCodeAttribute = $@"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(""{AssemblyName.Name}"", ""{AssemblyName.Version}"")]";

    private const string ExtravaCommandAttributeName = "ExtravaCore.ExtravaCommandAttribute";

    private static readonly string sourceText = $$"""
                // <auto-generated />
                #nullable enable
                using System;

                namespace ExtravaCore
                {
                    {{generatedCodeAttribute}}
                    [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
                    public sealed class ExtravaCommandAttribute : global::System.Attribute {}

                }
                """;
    public static void Generate(IncrementalGeneratorInitializationContext context) {
        // #if DEBUG
        //         if (!Debugger.IsAttached) {
        //             Debugger.Launch();
        //         }

        //         // while (!System.Diagnostics.Debugger.IsAttached)
        //         //     System.Threading.Thread.Sleep(500);
        // #endif

        Log.Print($"Executing {nameof(ExampleGenerator)}");
        context.RegisterPostInitializationOutput(ctx => {
            try {
                ctx.AddSource("ExtravaCore.ExtravaCommandAttributeGenerator.g.cs", SourceText.From(sourceText, Encoding.UTF8));
                Log.Print($"Added ExtravaCore.ExtravaCommandAttributeGenerator.g.cs");
            } catch (Exception ex) {
                Log.Print($"ExtravaCommandAttribute {nameof(Generate)} Exception {ex.Message}");
            }
            Log.FlushLogs(ctx);
        });

        var provider = context.SyntaxProvider.ForAttributeWithMetadataName(ExtravaCommandAttributeName, IsCommandClass, GetHierarchicFlow);
        // static (string TypeName, Accessibility ClassAccessibility) (GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken) => {
        //     var classDeclaration = context.TargetNode as ClassDeclarationSyntax; //context.TargetNode.FirstAncestorOrSelf<ClassDeclarationSyntax>();

        //     // Debug.Assert(context.TargetNode is ClassDeclarationSyntax);
        //     // Debug.Assert(context.TargetSymbol is INamedTypeSymbol);
        //     // Debug.Assert(!context.Attributes.IsEmpty);

        //     // var symbol = (INamedTypeSymbol)context.TargetSymbol; //Unsafe.As<INamedTypeSymbol>(context.TargetSymbol);
        //     // Console.WriteLine($"ExtravaCommandAttribute ClassName {symbol.Name}");
        //     // return (symbol.Name, symbol.DeclaredAccessibility);

        //     // Extract information from the context (e.g., node, attributes)
        //     var node = context.TargetNode; // The syntax node with [Copy] attribute
        //     var attributes = context.Attributes; // Any additional attributes associated with the node

        //     // Perform your transformation logic here
        //     // For example, create a new class based on the [Copy] attribute
        //     var className = $"Copy_{classDeclaration.Identifier.ValueText}";
        //     var classSource = $"public class {className} {{ /* Properties and methods */ }}";
        //     return (className, classDeclaration.Modifiers.ToAccessibility());
        // });

        context.RegisterSourceOutput(provider, (SourceProductionContext context, (string? ClassName, string? PropertyName, Accessibility? ClassAccessibility, string? Namespace, string? ResultType, string? OptionsType) info) => {
            try {
                if (info.ClassName is null || info.PropertyName is null || info.ClassAccessibility is null || info.Namespace is null || info.ResultType is null) {
                    Log.FlushLogs(context);
                    return;
                }

                using StringWriter writer = new(CultureInfo.InvariantCulture);
                using IndentedTextWriter source = new(writer);
                source.WriteLine("// <auto-generated />");
                source.WriteLine("#nullable enable");
                source.WriteLine($"namespace {info.Namespace} {{");
                source.Indent++;
                //source.WriteLine(generatedCodeAttribute);
                source.WriteLine($"public static partial class CommandDescriptors {{");
                source.Indent++;
                if (info.OptionsType is null) {
                    source.WriteLine($"public static CommandDescriptor<{info.ClassName}, {info.ResultType}> {info.PropertyName.Replace("Command", "")} {{ get; }}");
                } else {
                    source.WriteLine($"public static CommandDescriptor<{info.ClassName}, {info.ResultType}, {info.OptionsType}> {info.PropertyName.Replace("Command", "")} {{ get; }}");
                }
                source.Indent++;
                if (info.OptionsType is null) {
                    source.WriteLine($"= new CommandDescriptor<{info.ClassName}, {info.ResultType}>();");
                } else {
                    source.WriteLine($"= new CommandDescriptor<{info.ClassName}, {info.ResultType}, {info.OptionsType}>();");
                }
                source.Indent--;
                source.Indent--;
                source.WriteLine("}");
                source.Indent--;
                source.WriteLine("}");

                //Debug.Assert(source.Indent == 0);
                context.AddSource($"{info.ClassName}.g.cs", writer.ToString());
            } catch (Exception ex) {
                Log.Print($"ExtravaCommandAttribute {nameof(Generate)} Exception {ex.Message}");
                Log.FlushLogs(context);
            }

            Log.FlushLogs(context);
        });

    }
    public void Initialize(IncrementalGeneratorInitializationContext context) {
        Generate(context);
    }

    private static (string? ClassName, string? PropertyName, Accessibility? ClassAccessibility, string? Namespace, string? ResultType, string? OptionsType) GetHierarchicFlow(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken) {
        try {
            if (cancellationToken.IsCancellationRequested) {
                Log.Print($"ExtravaCommandAttribute {nameof(GetHierarchicFlow)} CancellationRequested");
                return default;
            }

            if (context.TargetSymbol is not INamedTypeSymbol classSymbol) {
                Log.Print($"ExtravaCommandAttribute Class Symbol is null");
                return default;
            }


            if (classSymbol.ContainingNamespace is null) {
                Log.Print($"ExtravaCommandAttribute Class Namespace is null");
                return default;
            }

            Log.Print($"ExtravaCommandAttribute ClassName {classSymbol.Name}");
            var extravaCommandAttribute = classSymbol.GetAttributes().FirstOrDefault(attr => attr.AttributeClass?.Name == ExtravaCommandAttributeName);
            var iCommandOptionsInterface = classSymbol.AllInterfaces.FirstOrDefault(i => i.Name.ToString() == "ICommandWrapperWithOptions");
            var iCommandNoInputInterface = classSymbol.AllInterfaces.FirstOrDefault(i => i.Name.ToString() == "ICommandWrapperWithNoInputResult");

            if (iCommandOptionsInterface is not null) {
                var iCommandGenericTypeArgs = iCommandOptionsInterface.TypeArguments.ToArray();
                var iCommandGenericType1 = iCommandGenericTypeArgs.Length > 0 ? iCommandGenericTypeArgs[0]?.ToDisplayString() : null;
                var iCommandGenericType2 = iCommandGenericTypeArgs.Length > 1 ? iCommandGenericTypeArgs[1]?.ToDisplayString() : null;
                Log.Print($"ExtravaCommandAttribute ({classSymbol.ToDisplayString()}, {classSymbol.DeclaredAccessibility}, {classSymbol.ContainingNamespace.ToDisplayString()}, {iCommandGenericType1}, {iCommandGenericType2})");

                return (classSymbol.ToDisplayString(), classSymbol.Name, classSymbol.DeclaredAccessibility, classSymbol.ContainingNamespace.ToDisplayString(), iCommandGenericType1, iCommandGenericType2);
            } else if (iCommandNoInputInterface is not null) {
                var iCommandGenericTypeArgs = iCommandNoInputInterface.TypeArguments.ToArray();
                var iCommandGenericType1 = iCommandGenericTypeArgs.Length > 0 ? iCommandGenericTypeArgs[0]?.ToDisplayString() : null;
                var iCommandGenericType2 = iCommandGenericTypeArgs.Length > 1 ? iCommandGenericTypeArgs[1]?.ToDisplayString() : null;
                Log.Print($"ExtravaCommandAttribute ({classSymbol.ToDisplayString()}, {classSymbol.DeclaredAccessibility}, {classSymbol.ContainingNamespace.ToDisplayString()}, {iCommandGenericType1}, null)");
                return (classSymbol.ToDisplayString(), classSymbol.Name, classSymbol.DeclaredAccessibility, classSymbol.ContainingNamespace.ToDisplayString(), iCommandGenericType1, null);
            }

            return default;
        } catch (Exception ex) {
            Log.Print($"ExtravaCommandAttribute {nameof(GetHierarchicFlow)} Exception {ex.Message}");
            return default;
        }
    }

    private static bool IsCommandClass(SyntaxNode node, CancellationToken cancellationToken) {
        try {
            return true;
            Log.Print($"ExtravaCommandAttribute Class eval");
            if (cancellationToken.IsCancellationRequested) {
                Log.Print($"ExtravaCommandAttribute {nameof(IsCommandClass)} CancellationRequested");
                return default;
            }

            if (node is ClassDeclarationSyntax classDeclaration && node is INamedTypeSymbol classSymbol) {
                // if (classDeclaration.BaseList is { Types.Count: > 0 } baseList) {
                //     return baseList.Types[0].Type is IdentifierNameSyntax { Identifier.Text: "Command" or "RootCommand" };
                // }
                Log.Print($"ExtravaCommandAttribute {nameof(IsCommandClass)} {classDeclaration.Identifier.ValueText} is ClassDeclarationSyntax and is INamedTypeSymbol");
                return classDeclaration.AttributeLists.Any(a => a.Attributes.Any(a => a.Name.ToString() == ExtravaCommandAttributeName))
                && classSymbol.Interfaces.Any(i => i.Name.ToString() == "ICommand" && i.TypeArguments.Count() == 1);
            }

            return false;
        } catch (Exception ex) {
            Log.Print($"ExtravaCommandAttribute {nameof(IsCommandClass)} Exception {ex.Message}");
            return default;
        }
    }

}

public static class ClassDeclerationExtensions {
    public static Accessibility ToAccessibility(this SyntaxTokenList modifiers) {
        var accessibility = Accessibility.NotApplicable;

        foreach (var modifier in modifiers) {
            switch (modifier.Kind()) {
                case SyntaxKind.PublicKeyword:
                    accessibility = Accessibility.Public;
                    break;
                case SyntaxKind.PrivateKeyword:
                    accessibility = Accessibility.Private;
                    break;
                case SyntaxKind.ProtectedKeyword:
                    accessibility = Accessibility.Protected;
                    break;
                case SyntaxKind.InternalKeyword:
                    accessibility = Accessibility.Internal;
                    break;
            }
        }

        return accessibility;
    }
}

// [Generator]
// public sealed class CommandDescriptorGenerator : ISourceGenerator
// {
//     public void Initialize(GeneratorInitializationContext context)
//     {
//         Console.WriteLine($"Executing {nameof(CommandDescriptorGenerator)}");
//         //context.RegisterForSyntaxNotifications(() => new ExtravaCommandSyntaxReceiver());
//     }
// }
// [Generator]
// public sealed class CommandDescriptorGenerator : ISourceGenerator
// {
//     public void Initialize(GeneratorInitializationContext context)
//     {

//         //context.RegisterForSyntaxNotifications(() => new ExtravaCommandSyntaxReceiver());
//     }

//     public void Execute(GeneratorExecutionContext context)
//     {
//         Console.WriteLine($"Executing {nameof(CommandDescriptorGenerator)}"
//             //context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor("ExtravaCommandGenerator", "ExtravaCommandGenerator", "ExtravaCommandGenerator", "ExtravaCommandGenerator", DiagnosticSeverity.Warning, true), Location.None));
//         context.AddSource("myGeneratedFile.cs", SourceText.From(@"
//         namespace GeneratedNamespace
//         {
//             public class GeneratedClass 
//             {
//                 public static void GeneratedMethod()
//                 {
//                     // generated code
//                 }
//             }
//         }", Encoding.UTF8));

//         // var compilation = context.Compilation;
//         // var attributeSymbol = compilation.GetTypeByMetadataName("ExtravaCore.Generators.ExtravaCommandAttribute");
//         // var sourceBuilder = new StringBuilder();
//         // var matchedClasses = new List<ISymbol>();
//         // if (context.SyntaxReceiver is ExtravaCommandSyntaxReceiver receiver) {
//         //     foreach (var candidateClass in receiver.CandidateClasses) {
//         //         var semanticModel = compilation.GetSemanticModel(candidateClass.SyntaxTree);
//         //         var classSymbol = semanticModel.GetDeclaredSymbol(candidateClass);

//         //         if (classSymbol.GetAttributes().Any(attr => attr.AttributeClass.Equals(attributeSymbol, SymbolEqualityComparer.Default))) {
//         //             matchedClasses.Add(classSymbol);
//         //         }
//         //     }

//         // }

//         // sourceBuilder.AppendLine("using ExtravaCore.Commands.Framework;");
//         // sourceBuilder.AppendLine("using ExtravaCore.Commands;");
//         // sourceBuilder.AppendLine("using ExtravaCore;");

//         // foreach (var namespaceGroup in matchedClasses.GroupBy(c => c.ContainingNamespace)) {
//         //     sourceBuilder.AppendLine($"namespace {namespaceGroup.Key}");
//         //     sourceBuilder.Append("{");
//         //     sourceBuilder.AppendLine("/// <summary>");
//         //     sourceBuilder.AppendLine($"/// Command descriptors for {namespaceGroup.Key}");
//         //     sourceBuilder.AppendLine("/// </summary>");
//         //     sourceBuilder.AppendLine("\tpublic static class CommandDescriptors");
//         //     sourceBuilder.Append("{");

//         //     foreach (var matchedClass in namespaceGroup.Select(c => c)) {
//         //         var candidateClass = matchedClass;
//         //         var resultType = "string";  // Placeholder. You'll need logic to infer this.
//         //         var optionsType = $"{candidateClass.Name}Options";

//         //         sourceBuilder.AppendLine($"\t\tpublic static CommandDescriptor<{candidateClass.Name}, {resultType}, {optionsType}> {candidateClass.Name.Replace("Command", "")} {{ get; }}");
//         //         sourceBuilder.Append($"= new CommandDescriptor<{candidateClass.Name}, {resultType}, {optionsType}>();");

//         //     }

//         //     sourceBuilder.AppendLine("\t}");
//         //     sourceBuilder.AppendLine("}");
//         // }



//         // context.AddSource("ExtravaCore.Gernerator.CommandDescriptors.g.cs", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
//     }

//     public class ExtravaCommandSyntaxReceiver : ISyntaxReceiver
//     {
//         // public List<ClassDeclarationSyntax> CandidateClasses { get; } = new List<ClassDeclarationSyntax>();

//         // public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
//         // {
//         //     if (syntaxNode is ClassDeclarationSyntax classDeclaration
//         //         && classDeclaration.AttributeLists.Count > 0) // rudimentary filter for classes with attributes
//         //     {
//         //         CandidateClasses.Add(classDeclaration);
//         //     }
//         // }

//         public List<ClassDeclarationSyntax> CandidateClasses { get; } = new List<ClassDeclarationSyntax>();

//         public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
//         {
//             if (syntaxNode is ClassDeclarationSyntax classDeclaration)
//             {
//                 foreach (var attributeList in classDeclaration.AttributeLists)
//                 {
//                     foreach (var attribute in attributeList.Attributes)
//                     {
//                         if (attribute.Name.ToString() == "ExtravaCommand" || attribute.Name.ToString() == "ExtravaCommandAttribute")
//                         {
//                             CandidateClasses.Add(classDeclaration);
//                             return; // No need to process further attributes on this class
//                         }
//                     }
//                 }
//             }
//         }
//     }
// }