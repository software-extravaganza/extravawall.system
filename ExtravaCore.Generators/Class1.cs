using System.Linq;
using Microsoft.CodeAnalysis;
using System.Text;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Reflection;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Globalization;
using System.CodeDom.Compiler;
using Microsoft.CodeAnalysis.CSharp;


namespace ExtravaCore.Generators;



[Generator(LanguageNames.CSharp)]
public sealed class ExampleGenerator : IIncrementalGenerator {
    private static readonly AssemblyName AssemblyName = typeof(ExampleGenerator).Assembly.GetName();
    private static readonly string generatedCodeAttribute = $@"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(""{AssemblyName.Name}"", ""{AssemblyName.Version}"")]";

    private const string ExtravaCommandAttributeName = "ExtravaCore.ExtravaCommandAttribute";

    private static readonly string sourceText = $$"""
                // <auto-generated />
                #nullable enable
                using System;

                namespace ExtravaCore
                {
                    {{generatedCodeAttribute}}
                    [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
                    public sealed class ExtravaCommandAttribute : global::System.Attribute {}

                }
                """;
    public static void Generate(IncrementalGeneratorInitializationContext context) {
        // #if DEBUG
        //         if (!Debugger.IsAttached) {
        //             Debugger.Launch();
        //         }

        //         // while (!System.Diagnostics.Debugger.IsAttached)
        //         //     System.Threading.Thread.Sleep(500);
        // #endif

        Console.WriteLine($"Executing {nameof(ExampleGenerator)}");
        context.RegisterPostInitializationOutput(ctx => {
            ctx.AddSource("ExtravaCore.ExtravaCommandAttributeGenerator.g.cs", SourceText.From(sourceText, Encoding.UTF8));
            Console.WriteLine($"Added ExtravaCore.ExtravaCommandAttributeGenerator.g.cs");
        });

        var provider = context.SyntaxProvider.ForAttributeWithMetadataName(ExtravaCommandAttributeName, IsCommandClass, GetHierarchicFlow);
        // static (string TypeName, Accessibility ClassAccessibility) (GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken) => {
        //     var classDeclaration = context.TargetNode as ClassDeclarationSyntax; //context.TargetNode.FirstAncestorOrSelf<ClassDeclarationSyntax>();

        //     // Debug.Assert(context.TargetNode is ClassDeclarationSyntax);
        //     // Debug.Assert(context.TargetSymbol is INamedTypeSymbol);
        //     // Debug.Assert(!context.Attributes.IsEmpty);

        //     // var symbol = (INamedTypeSymbol)context.TargetSymbol; //Unsafe.As<INamedTypeSymbol>(context.TargetSymbol);
        //     // Console.WriteLine($"ExtravaCommandAttribute ClassName {symbol.Name}");
        //     // return (symbol.Name, symbol.DeclaredAccessibility);

        //     // Extract information from the context (e.g., node, attributes)
        //     var node = context.TargetNode; // The syntax node with [Copy] attribute
        //     var attributes = context.Attributes; // Any additional attributes associated with the node

        //     // Perform your transformation logic here
        //     // For example, create a new class based on the [Copy] attribute
        //     var className = $"Copy_{classDeclaration.Identifier.ValueText}";
        //     var classSource = $"public class {className} {{ /* Properties and methods */ }}";
        //     return (className, classDeclaration.Modifiers.ToAccessibility());
        // });

        context.RegisterSourceOutput(provider, (SourceProductionContext context, (string ClassName , Accessibility ClassAccessibility , string Namespace) info) => {
            using StringWriter writer = new(CultureInfo.InvariantCulture);
            using IndentedTextWriter source = new(writer);
            source.WriteLine("// <auto-generated />");
            source.WriteLine("#nullable enable");
            source.WriteLine($"namespace {info.Namespace} {{");
            source.Indent++;
            source.WriteLine(generatedCodeAttribute);
            source.WriteLine($"public static partial class CommandDescriptors {{");
            source.Indent++;
            source.WriteLine($"public static CommandDescriptor<{info.ClassName}, string, {info.ClassName}Options> {info.ClassName.Replace("Command", "")} {{ get; }}");
            source.Indent++;
            source.WriteLine("= new CommandDescriptor<{info.ClassName}, string, {info.ClassName}Options>();");
            source.Indent--;
            source.Indent--;
            source.WriteLine("}");
            source.Indent--;
            source.WriteLine("}");

            //Debug.Assert(source.Indent == 0);
            context.AddSource($"{info.Namespace}.{info.ClassName}.g.cs", writer.ToString());
        });
    }
    public void Initialize(IncrementalGeneratorInitializationContext context) {
        Generate(context);
    }

    private static (string ClassName, Accessibility ClassAccessibility, string Namespace) GetHierarchicFlow(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken) {
        if (context.TargetSymbol is not INamedTypeSymbol classSymbol) {
            return ("Bob", Accessibility.Public, "ExtravaCore");
        }

        return (classSymbol.Name, classSymbol.DeclaredAccessibility, classSymbol.ContainingNamespace.ToDisplayString());
    }

    private static bool IsCommandClass(SyntaxNode node, CancellationToken cancellationToken) {
        return node is ClassDeclarationSyntax;


        if (node is ClassDeclarationSyntax classDeclaration) {
            // if (classDeclaration.BaseList is { Types.Count: > 0 } baseList) {
            //     return baseList.Types[0].Type is IdentifierNameSyntax { Identifier.Text: "Command" or "RootCommand" };
            // }
            return classDeclaration.AttributeLists.Any(a => a.Attributes.Any(a => a.Name.ToString() == ExtravaCommandAttributeName));
        }

        return false;
    }

}

public static class ClassDeclerationExtensions {
    public static Accessibility ToAccessibility(this SyntaxTokenList modifiers) {
        var accessibility = Accessibility.NotApplicable;

        foreach (var modifier in modifiers) {
            switch (modifier.Kind()) {
                case SyntaxKind.PublicKeyword:
                    accessibility = Accessibility.Public;
                    break;
                case SyntaxKind.PrivateKeyword:
                    accessibility = Accessibility.Private;
                    break;
                case SyntaxKind.ProtectedKeyword:
                    accessibility = Accessibility.Protected;
                    break;
                case SyntaxKind.InternalKeyword:
                    accessibility = Accessibility.Internal;
                    break;
            }
        }

        return accessibility;
    }
}

// [Generator]
// public sealed class CommandDescriptorGenerator : ISourceGenerator
// {
//     public void Initialize(GeneratorInitializationContext context)
//     {
//         Console.WriteLine($"Executing {nameof(CommandDescriptorGenerator)}");
//         //context.RegisterForSyntaxNotifications(() => new ExtravaCommandSyntaxReceiver());
//     }
// }
// [Generator]
// public sealed class CommandDescriptorGenerator : ISourceGenerator
// {
//     public void Initialize(GeneratorInitializationContext context)
//     {

//         //context.RegisterForSyntaxNotifications(() => new ExtravaCommandSyntaxReceiver());
//     }

//     public void Execute(GeneratorExecutionContext context)
//     {
//         Console.WriteLine($"Executing {nameof(CommandDescriptorGenerator)}"
//             //context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor("ExtravaCommandGenerator", "ExtravaCommandGenerator", "ExtravaCommandGenerator", "ExtravaCommandGenerator", DiagnosticSeverity.Warning, true), Location.None));
//         context.AddSource("myGeneratedFile.cs", SourceText.From(@"
//         namespace GeneratedNamespace
//         {
//             public class GeneratedClass 
//             {
//                 public static void GeneratedMethod()
//                 {
//                     // generated code
//                 }
//             }
//         }", Encoding.UTF8));

//         // var compilation = context.Compilation;
//         // var attributeSymbol = compilation.GetTypeByMetadataName("ExtravaCore.Generators.ExtravaCommandAttribute");
//         // var sourceBuilder = new StringBuilder();
//         // var matchedClasses = new List<ISymbol>();
//         // if (context.SyntaxReceiver is ExtravaCommandSyntaxReceiver receiver) {
//         //     foreach (var candidateClass in receiver.CandidateClasses) {
//         //         var semanticModel = compilation.GetSemanticModel(candidateClass.SyntaxTree);
//         //         var classSymbol = semanticModel.GetDeclaredSymbol(candidateClass);

//         //         if (classSymbol.GetAttributes().Any(attr => attr.AttributeClass.Equals(attributeSymbol, SymbolEqualityComparer.Default))) {
//         //             matchedClasses.Add(classSymbol);
//         //         }
//         //     }

//         // }

//         // sourceBuilder.AppendLine("using ExtravaCore.Commands.Framework;");
//         // sourceBuilder.AppendLine("using ExtravaCore.Commands;");
//         // sourceBuilder.AppendLine("using ExtravaCore;");

//         // foreach (var namespaceGroup in matchedClasses.GroupBy(c => c.ContainingNamespace)) {
//         //     sourceBuilder.AppendLine($"namespace {namespaceGroup.Key}");
//         //     sourceBuilder.Append("{");
//         //     sourceBuilder.AppendLine("/// <summary>");
//         //     sourceBuilder.AppendLine($"/// Command descriptors for {namespaceGroup.Key}");
//         //     sourceBuilder.AppendLine("/// </summary>");
//         //     sourceBuilder.AppendLine("\tpublic static class CommandDescriptors");
//         //     sourceBuilder.Append("{");

//         //     foreach (var matchedClass in namespaceGroup.Select(c => c)) {
//         //         var candidateClass = matchedClass;
//         //         var resultType = "string";  // Placeholder. You'll need logic to infer this.
//         //         var optionsType = $"{candidateClass.Name}Options";

//         //         sourceBuilder.AppendLine($"\t\tpublic static CommandDescriptor<{candidateClass.Name}, {resultType}, {optionsType}> {candidateClass.Name.Replace("Command", "")} {{ get; }}");
//         //         sourceBuilder.Append($"= new CommandDescriptor<{candidateClass.Name}, {resultType}, {optionsType}>();");

//         //     }

//         //     sourceBuilder.AppendLine("\t}");
//         //     sourceBuilder.AppendLine("}");
//         // }



//         // context.AddSource("ExtravaCore.Gernerator.CommandDescriptors.g.cs", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
//     }

//     public class ExtravaCommandSyntaxReceiver : ISyntaxReceiver
//     {
//         // public List<ClassDeclarationSyntax> CandidateClasses { get; } = new List<ClassDeclarationSyntax>();

//         // public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
//         // {
//         //     if (syntaxNode is ClassDeclarationSyntax classDeclaration
//         //         && classDeclaration.AttributeLists.Count > 0) // rudimentary filter for classes with attributes
//         //     {
//         //         CandidateClasses.Add(classDeclaration);
//         //     }
//         // }

//         public List<ClassDeclarationSyntax> CandidateClasses { get; } = new List<ClassDeclarationSyntax>();

//         public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
//         {
//             if (syntaxNode is ClassDeclarationSyntax classDeclaration)
//             {
//                 foreach (var attributeList in classDeclaration.AttributeLists)
//                 {
//                     foreach (var attribute in attributeList.Attributes)
//                     {
//                         if (attribute.Name.ToString() == "ExtravaCommand" || attribute.Name.ToString() == "ExtravaCommandAttribute")
//                         {
//                             CandidateClasses.Add(classDeclaration);
//                             return; // No need to process further attributes on this class
//                         }
//                     }
//                 }
//             }
//         }
//     }
// }