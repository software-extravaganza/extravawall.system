
//------------------------------------------------------------------------------

//  <auto-generated>
//      This code was generated by:
//        TerminalGuiDesigner v1.0.22.0
//      You can make changes to this file and they will not be overwritten when saving.
//  </auto-generated>
// -----------------------------------------------------------------------------

using ExtravaWall.Network;
using Humanizer;

namespace ExtravaWallSetup.GUI {
    using DynamicData;
    using ExtravaWallSetup.GUI.Framework;
    using Hardware.Info;
    using System;
    using System.Data;
    using System.Diagnostics;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Threading.Tasks;
    using Terminal.Gui;
    using Terminal.Gui.Graphs;
    using static Terminal.Gui.Graphs.BarSeries;

    public partial class DefaultScreen {
        private HardwareInfo _hardwareInfo;
        private DateTime _startTime;
        private Timer _systemTimer;
        private DiscoBarSeries _memSeries;
        private List<BarSeries.Bar> _memBars;
        private DiscoBarSeries _cpuSeries;
        private int _systemTimerTick = 500;
        private ScatterSeries _memPoints;
        private ScatterSeries _cpuPoints;
        private List<Bar> _cpuBars;
        private List<Bar> _networkBars;
        private float _memPercentage;
        private float _cpuPercentage;
        private ColorScheme _defaultInfoTableColorScheme;
        private ColorScheme _defaultInfoTableColumnColorScheme;
        public ExtravaScrollView VirtualConsoleView => consoleScrollView;
        private TaskCompletionSource _layoutInitializedCompletionSource;
        public Task LayoutInitialized => _layoutInitializedCompletionSource.Task;
        public TableView InfoTable => infoTable;

        public override bool ProcessHotKey(KeyEvent keyEvent) {
            if (keyEvent.Key == Key.Esc) {
                Terminal.Gui.Application.Shutdown();
            }

            return base.ProcessHotKey(keyEvent);
        }

        public DefaultScreen(TaskCompletionSource layoutInitializedCompletionSource) {
            _layoutInitializedCompletionSource = layoutInitializedCompletionSource;

            InitializeComponent();
            _memPoints = new ScatterSeries();
            _cpuPoints = new ScatterSeries();
            _networkPoints = new ScatterSeries();
            _hardwareInfo = new HardwareInfo();

            _startTime = DateTime.Now;


            _memSeries = new DiscoBarSeries();
            _memBars = new List<BarSeries.Bar>();
            _cpuSeries = new DiscoBarSeries();
            _cpuBars = new List<BarSeries.Bar>();
            _networkSeries = new DiscoBarSeries(10_000);
            _networkBars = new List<BarSeries.Bar>();
            _memSeries.Bars = _memBars;
            _cpuSeries.Bars = _cpuBars;
            _networkSeries.Bars = _networkBars;
            memGraph.Series.Add(_memSeries);
            cpuGraph.Series.Add(_cpuSeries);
            networkGraph.Series.Add(_networkSeries);
            memGraph.AutoSize = true;
            cpuGraph.AutoSize = true;
            networkGraph.AutoSize = true;
            _defaultInfoTableColorScheme = new ColorScheme() {
                Normal = new Terminal.Gui.Attribute(Color.Gray, Color.Blue)
            };
            _defaultInfoTableColumnColorScheme = new ColorScheme() {
                Normal = new Terminal.Gui.Attribute(Color.White)
            };

            infoTable.Style.RowColorGetter = (a) => _defaultInfoTableColorScheme;
            consoleScrollView.LayoutComplete += consoleScrollView_LayoutCompleteAsync;
            consoleScrollView.KeepContentAlwaysInViewport = true;
            consoleScrollView.Enabled = true;
            consoleScrollView.Visible = true;
            consoleScrollView.ShowHorizontalScrollIndicator = true;
            consoleScrollView.ShowVerticalScrollIndicator = true;
            consoleScrollView.ColorScheme = Colors.TopLevel;
            consoleScrollView.WantMousePositionReports = true;
            //consoleScrollView.SetFocus();
            consoleScrollView.AutoSize = true;
        }

        private void consoleScrollView_LayoutCompleteAsync(LayoutEventArgs obj) {
            if (!_layoutInitializedCompletionSource.Task.IsCompleted) {
                _layoutInitializedCompletionSource.SetResult();
            }
        }


        private (ulong tx, ulong rx) _networkInfo;
        private DateTime _networkInfoTimestamp;
        private (ulong tx, ulong rx) _previousNetworkInfo;
        private DateTime _previousNetworkInfoTimestamp;
        private double _networkUpSpeed;
        private double _networkDownSpeed;
        private readonly object _chartDataLock = new object();
        private readonly DiscoBarSeries _networkSeries;

        private readonly ScatterSeries _networkPoints;


        private async Task updateGraphs() {

            _previousNetworkInfo = _networkInfo;
            _previousNetworkInfoTimestamp = _networkInfoTimestamp;
            _networkInfo = NetworkHelpers.GetBytesSentReceived();
            _networkInfoTimestamp = DateTime.Now;
            _hardwareInfo.RefreshMemoryStatus();
            _hardwareInfo.RefreshCPUList();
            //var timeDiff = (float)(DateTime.Now - _startTime).TotalMilliseconds;
            _memPercentage = (float)(1m - ((decimal)_hardwareInfo.MemoryStatus.AvailablePhysical / _hardwareInfo.MemoryStatus.TotalPhysical));
            _cpuPercentage = (float)(_hardwareInfo.CpuList.Average(c => (decimal)c.PercentProcessorTime) / 100);
            var bytesUp = (float)_networkInfo.tx - _previousNetworkInfo.tx;
            bytesUp = bytesUp < 0 ? 0 : bytesUp;
            var bytesDown = (float)_networkInfo.rx - _previousNetworkInfo.rx;
            bytesDown = bytesDown < 0 ? 0 : bytesDown;

            _networkUpSpeed = bytesUp <= 0 ? 0 : bytesUp / (_networkInfoTimestamp - _previousNetworkInfoTimestamp).TotalSeconds;
            _networkDownSpeed = bytesDown <= 0 ? 0 : bytesDown / (_networkInfoTimestamp - _previousNetworkInfoTimestamp).TotalSeconds;
            //var newMemPoint = new PointF(timeDiff / 1000, _memPercentage);
            //var newCpuPoint = new PointF(timeDiff / 1000, _cpuPercentage);
            var stiple = new GraphCellToRender('\u2588');
            //_memPoints.Points.Add(newMemPoint);
            try {
                lock (_chartDataLock) {  //_cpuPoints.Points.Add(newCpuPoint);
                    _memBars.Add(new BarSeries.Bar(null, stiple, _memPercentage));
                    _cpuBars.Add(new BarSeries.Bar(null, stiple, _cpuPercentage));
                    _networkBars.Add(new BarSeries.Bar(null, stiple, bytesUp / 1000f));
                    _networkBars.Add(new BarSeries.Bar(null, stiple, bytesDown / 1000f));
                    memGraph.GetCurrentWidth(out int memGraphWidth);
                    cpuGraph.GetCurrentWidth(out int cpuGraphWidth);
                    networkGraph.GetCurrentWidth(out int networkGraphWidth);
                    memGraph.GetCurrentHeight(out int memGraphHeight);
                    cpuGraph.GetCurrentHeight(out int cpuGraphHeight);
                    networkGraph.GetCurrentHeight(out int networkGraphHeight);

                    while (_memBars.Count > memGraphWidth && _memBars.Count > 0) {
                        _memBars.RemoveAt(0);
                    }

                    while (_cpuBars.Count > cpuGraphWidth && _cpuBars.Count > 0) {
                        _cpuBars.RemoveAt(0);
                    }

                    while (_networkBars.Count > networkGraphWidth && _networkBars.Count > 0) {
                        _networkBars.RemoveAt(0);
                    }
                }
            } catch (ArgumentOutOfRangeException) {
                // todo: log?
                // swallow
            }
            //memGraph.ScrollOffset = new PointF(_memGraphOffset, 0);
            //cpuGraph.ScrollOffset = new PointF(_cpuGraphOffset, 0);
            await Task.CompletedTask;
        }

        private void drawGraphs() {
            //var memLine = new PathAnnotation() {
            //    LineColor = Application.Driver.MakeAttribute(Color.Green, Color.Black),
            //    Points = _memPoints.Points.ToList(),
            //    BeforeSeries = true,
            //};
            //memGraph.Annotations.Add(memLine);

            //var cpuLine = new PathAnnotation() {
            //    LineColor = Application.Driver.MakeAttribute(Color.BrightCyan, Color.Black),
            //    Points = _cpuPoints.Points.ToList(),
            //    BeforeSeries = true,
            //};
            //cpuGraph.Annotations.Add(cpuLine);

            memGraph.SetNeedsDisplay();
            cpuGraph.SetNeedsDisplay();
            networkGraph.SetNeedsDisplay();
            cpuGraphLabel.Text = _cpuPercentage.ToString("CPU - 00%");
            memGraphLabel.Text = _memPercentage.ToString("Mem - 00%");

            var humanizedUpload = (_networkUpSpeed == Double.NaN || _networkUpSpeed <= 0 ? 0 : _networkUpSpeed).Bytes().Per(1.Seconds()).Humanize("#").Replace(" ", "").PadLeft(7);
            var humanizedDownload = (_networkDownSpeed == Double.NaN || _networkDownSpeed <= 0 ? 0 : _networkDownSpeed).Bytes().Per(1.Seconds()).Humanize("#").Replace(" ", "").PadLeft(7);
            networkGraphLabel.Text = _memPercentage.ToString($"Net - {UP_ARROW}{humanizedUpload} {DOWN_ARROW}{humanizedDownload}");


        }

        public void Initialize() {
            _systemTimer = new Timer(async (o) => {
                // Note the check for Mainloop being valid. System.Timers can run after they are Disposed.
                // This code must be defensive for that. 
                await updateGraphs();
                Application.MainLoop?.Invoke(drawGraphs);

            }, null, 0, _systemTimerTick);
        }

        private const char UP_ARROW = (char)9650;
        private const char DOWN_ARROW = (char)9660;
    }




}
